\documentclass[final,twoside,spanish,a4paper,12pt]{book}
\usepackage{cclicenses}
\exhyphenpenalty=10000

\usepackage{cmll}
\usepackage{fancyhdr}
\usepackage{amssymb,amsmath,amsthm}
\usepackage[top=1in, bottom=1.5in, left=1in, right=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{needspace}
\usepackage{tikz}
\usetikzlibrary{cd,positioning,decorations.text}
\tikzcdset{scale cd/.style={every label/.append style={scale=#1},cells={nodes={scale=#1}}}}
\usepackage[spanish,es-nodecimaldot]{babel}
\usepackage{multicol}
\usepackage{url}
\usepackage{lastpage}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{nicefrac}
\usepackage{bm}
\usepackage{enumitem}
\usepackage{cancel}
\usepackage[llbracket,rrbracket]{stmaryrd}
\usepackage{pifont}
\renewcommand\thefootnote{\ding{\numexpr171+\value{footnote}}}
\usepackage{soul,color}
\usepackage{proof}
\usepackage[square]{natbib}
\usepackage[colorlinks,
  urlcolor=blue,
  linkcolor=blue,
  citecolor=blue,
  filecolor=black,
bookmarks]
{hyperref}
\usepackage{adjustbox,varwidth,xparse}
\usepackage{qcircuit}

\allowdisplaybreaks

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3} 

\parindent 0pt


\newcommand{\boxedheader}[1]{%
  \tikz[baseline=(X.base)]{
    \node[
      fill=gray!20,
      draw=black,
      rounded corners=3pt,
      inner xsep=4pt,
      inner ysep=2pt
    ] (X) {#1};
  }%
}

\newtheoremstyle{ejercicioBox}% nombre del estilo
  {}{}% espacio arriba/abajo
  {}% fuente del cuerpo
  {}% indentación
  {\bfseries}% fuente del encabezado
  {}% puntuación después del encabezado
  { }% espacio después del encabezado
  {\boxedheader{\thmname{#1}\thmnumber{ #2}}\thmnote{ (#3)}}%

\newtheoremstyle{defStyle}{}{}{}{}{\color{blue!50!black}\bfseries}{}{ }{}
\theoremstyle{defStyle}
\newtheorem{definicion}{Definición}[chapter]
\newtheoremstyle{thmStyle}{}{}{}{}{\color{red!50!black}\bfseries}{}{ }{}
\theoremstyle{thmStyle}
\newtheorem{teorema}[definicion]{Teorema}
\newtheorem{lema}[definicion]{Lema}
\newtheorem{corolario}[definicion]{Corolario}
\newtheorem*{propiedades}{Propiedades}
\newtheorem*{propiedad}{Propiedad}
\declaretheorem[style=definition]{postulado}
\addtotheorempreheadhook[postulado]{%
  \moveright\dimexpr(\linewidth-35em)/2\vbox\bgroup
  \hsize=35em
  \linewidth=\hsize
}
\addtotheorempostfoothook[postulado]{\egroup}
\newenvironment{postuladobis}[1]
{\renewcommand{\thepostulado}{\ref{#1}$'$}%
  \addtocounter{postulado}{-1}%
  \begin{postulado}}
{\end{postulado}}
\newenvironment{postuladoAlt}[1]
{\renewcommand{\thepostulado}{\ref{#1}}%
  \addtocounter{postulado}{-4}%
  \begin{postulado}}
{\end{postulado}}
\theoremstyle{remark}
\newtheorem*{observacion}{Observación}
\newtheorem*{observaciones}{Observaciones}
\newtheoremstyle{ejemploStyle}{}{}{}{}{\color{green!50!black}\bfseries}{}{ }{}
\theoremstyle{ejemploStyle}
\newtheorem{ejemplo}[definicion]{Ejemplo}
\theoremstyle{ejercicioBox}
\newtheorem{ejercicio}{Ejercicio}[part]

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO,LE]{\thepage}
\fancyhead[LO]{\rmfamily\sc\nouppercase\leftmark}
\fancyhead[RE]{\rmfamily\sc\nouppercase\rightmark}
\setlength{\headheight}{27.16pt}


\newcommand\concat{\ensuremath{\mathop{+\!\!+}}}
\newcommand\Obj{\ensuremath{\mathbf{Obj}}}
\newcommand\Arr{\ensuremath{\mathbf{Arr}}}
\newcommand\Id{\ensuremath{\mathsf{Id}}}
\newcommand\Home[3][\mathsf{Set}]{\mathsf{Hom}_{#1}({#2},{#3})} 
\newcommand\home[2]{[{#1},{#2}]} 
\newcommand\coprodu[2]{\left[{#1},{#2}\right]} 
\newcommand\xlra[1]{\overset{#1}{\longrightarrow}}
\newcommand\inl{\mathsf{inl}}
\newcommand\inr{\mathsf{inr}}
\newcommand\elimtop[2]{\ensuremath{{#1};{#2}}}
\newcommand\elimbot[1]{\ensuremath{\mathsf{err}(#1)}}
\newcommand\elimandl[1]{\ensuremath{\pi_1{#1}}}
\newcommand\elimandr[1]{\ensuremath{\pi_2{#1}}}
\newcommand\elimor[5]{\ensuremath{\mathsf{match}(#1,#2.#3,#4.#5)}}
\newcommand\B{\mathbb B}
\newcommand\Q{\B}
\newcommand\tbasis{\ensuremath{\mathfrak B}}
\newcommand\types{\ensuremath{\mathcal T}}
\newcommand\qtypes{\ensuremath{\mathcal Q}}
\newcommand\values{\ensuremath{\mathcal V}}
\newcommand\One{\bm{1}}
\newcommand\Zero{\bm{0}}
\newcommand\SN{\ensuremath{\mathcal{SN}}}
\newcommand\Neu{\ensuremath{\mathcal N}}
\newcommand\Red[1]{\ensuremath{\mathsf{Red}(#1)}}
\newcommand\CR[1]{\ensuremath{(\mathsf{CR}_{#1})}}
\newcommand\RC{\ensuremath{\mathcal{RC}}}
\newcommand\conlista{\leavevmode\vspace{-0.4\baselineskip}}
\newcommand\prodi[2]{\langle #1, #2 \rangle}
\newcommand\norma[1]{\Vert #1 \Vert}
\newcommand\braket[2]{\langle{#1}|{#2}\rangle}
\newcommand\matriz[1]{\begin{pmatrix}#1\end{pmatrix}}
\newcommand\conj[1]{#1^*}
\newcommand\adj[1]{#1^\dagger}
\newcommand\trans[1]{#1^T}
\newcommand\inv[1]{#1^{-1}}
\newcommand\ket[1]{|#1\rangle}
\newcommand\bra[1]{\langle #1|}
\newcommand\tr{\ensuremath{\mathsf{tr}}}
\newcommand\ifz[3]{\ensuremath{\mathsf{isZ}({#1})?{#2}\!:\!{#3}}}
\newcommand\ite[3]{\ifz{#1}{#2}{#3}}
\newcommand\fun[2]{\ensuremath{\lambda #1.#2}}
\newcommand\fix[2]{\ensuremath{ \mu #1.#2}}
\newcommand\letl[3]{\ensuremath{\mathsf{let~}#1=#2\mathsf{~in~}#3}}
\newcommand\nat{\ensuremath{\mathsf{nat}}}
\newcommand\fst{\ensuremath{\pi_1}}
\newcommand\snd{\ensuremath{\pi_2}}
\newcommand\FV{\ensuremath{\mathsf{FV}}}
\newcommand\mgu{\ensuremath{\mathsf{mgu}}}
\newcommand\Gen{\ensuremath{\mathsf{Gen}}}
\newcommand\s[1]{\ensuremath{\mathsf{#1}}}
\newcommand\thunk[2]{\ensuremath{\langle{#1},{#2}\rangle}}
\newcommand\cierre[3]{\ensuremath{\thunk{{#1},{#2}}{#3}}}
\newcommand\hra{\ensuremath{\hookrightarrow}}
\newcommand\sem[1]{\ensuremath{\left\llbracket {#1}\right\rrbracket}}
\newcommand\semT[2][\theta]{\ensuremath{\sem{#2}_{#1}}}
\newcommand\promote[3]{\ensuremath{\mathsf{promote}\ #1\ \mathsf{for}\ #2\ \mathsf{in}\ #3}}
\newcommand\derelict[1]{\ensuremath{\mathsf{derelict}\ #1}}
\newcommand\discard[2]{\ensuremath{\mathsf{discard}\ #1\ \mathsf{in}\ #2}}
\newcommand\copyt[3]{\ensuremath{\mathsf{copy}\ #1\ \mathsf{as}\ #2\ \mathsf{in}\ #3}}
\newcommand\prog[2]{[{#1},{#2}]}
\newcommand\newq{\ensuremath{\mathsf{new}}}
\newcommand\meas{\ensuremath{\mathsf{meas}}}
\newcommand\bit{\ensuremath{\mathsf{bit}}}
\newcommand\qbit{\ensuremath{\mathsf{qbit}}}
\newcommand\te[1]{\ensuremath{\mathit{#1}}}
\newcommand\un[1]{\ensuremath{\mathcal{#1}}}
\newcommand\gen[1]{\ensuremath{\mathbb{#1}}}
\newcommand\z[1][A]{\vec 0_{S(#1)}}
\newcommand\pair[2]{\langle{#1},{#2}\rangle}
\newcommand\lra{\longrightarrow}
\newcommand\may[1][\alpha]{[{#1}.]}
\newcommand\titulo[3][\scriptsize]{\rotatebox[origin=c]{90}{\parbox[t]{#2}{\centering #1{#3}}}}
\newcommand\tax{\textsl{Ax}}
\newcommand\tif{\textsl{If}}
\newcommand\rbetab{(\s{\beta_b})}
\newcommand\rbetan{(\s{\beta_n})}
\newcommand\riftrue{(\s{if_{1}})}
\newcommand\riffalse{(\s{if_{0}})}
\newcommand\rlinr{(\s{lin^+_r})}
\newcommand\rlinscalr{(\s{lin^\alpha_r})}
\newcommand\rlinzr{(\s{lin^0_r})}
\newcommand\rlinl{(\s{lin^+_l})}
\newcommand\rlinscall{(\s{lin^\alpha_l})}
\newcommand\rlinzl{(\s{lin^0_l})}
\newcommand\rneut{(\s{neutral})}
\newcommand\runit{(\s{unit})}
\newcommand\rzeros{(\s{zero_\alpha})}
\newcommand\rzeroS{(\s{zero_S})}
\newcommand\rzero{(\s{zero})}
\newcommand\rprod{(\s{prod})}
\newcommand\rdists{(\s{\alpha dist})}
\newcommand\rdistcasum{(\s{dist^+_\Uparrow})}
\newcommand\rdistcascal{(\s{dist^\alpha_\Uparrow})}
\newcommand\rcaneutl{(\s{neut^\Uparrow_l})}
\newcommand\rcaneutr{(\s{neut^\Uparrow_r})}
\newcommand\rfact{(\s{fact})}
\newcommand\rfacto{(\s{fact^1})}
\newcommand\rfactt{(\s{fact^2})}
\newcommand\rproj{(\s{proj})}
\newcommand\rehead{(\s{head})}
\newcommand\rtail{(\s{tail})}
\newcommand\rdistzr{(\s{dist^0_r})}
\newcommand\rdistzl{(\s{dist^0_l})}
\newcommand\rdistscalr{(\s{dist^\alpha_r})}
\newcommand\rdistscall{(\s{dist^\alpha_l})}
\newcommand\rdistsumr{(\s{dist^+_r})}
\newcommand\rdistsuml{(\s{dist^+_l})}
\newcommand\rcomm{(\s{comm})}
\newcommand\rassoc{(\s{assoc})}
\newcommand\cas[2]{\Uparrow^{\scriptscriptstyle S({#2})}_{\scriptscriptstyle S({#1})}}
\newcommand\head{\text{\sl head}}
\newcommand\tail{\text{\sl tail}}
\newcommand\red[2][1]{\overset{\scriptscriptstyle\smash{#2}\vphantom{x}}{\lra[#1]}\ }
\newcommand\npair[2]{({#1}-{#2})}

\newcommand{\roundarrow}{
  \tikz[baseline=-0.5ex]{
    \draw[line width=0.9pt] (0,0) -- (0.4,0);
    \draw[line width=0.9pt] (0.4,0) circle (0.07);
  }
}

\date{Versión (incompleta) del \today}
\usepackage{graphicx} % Required for inserting images

\title{TP-Fundamentos de lenguajes para computacion cuantica}
\author{Matias Flores -  Ignacio Bousoño  - Gonzalo Lafuente}

\begin{document}

\maketitle

\section{Ejercicios}

\subsection{Parte 1}

\begin{ejercicio}
Determinar cuáles de los siguientes son términos bien formados según la gramática extendida del cálculo lambda, y justificar:
\begin{enumerate}[label=\arabic*.]
    \item $\lambda x.\langle x, \inl(\star)\rangle$
    \item $\star;$
    \item $\langle \lambda x.x, y z\rangle$
    \item $\mathsf{match}(t, x.r, y.)$
\end{enumerate}
En cada caso, indicar por qué es correcto o por qué no lo es.
\end{ejercicio}

\textbf{Solución:}


\begin{enumerate}[label=\arabic*.]
    \item $\lambda x.\langle x, \inl(\star)\rangle$
    
    \begin{itemize}
        \item La construcción $\lambda x.t$ requiere que $t$ sea un término bien formado.
        \item $t = \langle x, \inl(\star)\rangle$ es un par $\langle t_1, t_2\rangle$
        \item $t_1 = x$ es una variable $\rightarrow$ bien formada
        \item $t_2 = \inl(\star)$ donde:
        \begin{itemize}
            \item $\inl(t')$ requiere $t'$ bien formado
            \item $t' = \star$ es el par vacío $\rightarrow$ bien formado
        \end{itemize}
    \end{itemize}
    \textcolor{green!50!black}{El término está bien formado}
    
    \item $\star;$
    
    \begin{itemize}
        \item La construcción $t;r$ requiere dos términos $t$ y $r$
        \item $t = \star$ es bien formado (par vacío)
        \item Falta el segundo término $r$ después del `;'
        \item La gramática exige que estén los dos terminos: $t;t$ 
    \end{itemize}
    \textcolor{red!50!black}{El término no está bien formado,}
    
    \item $\langle \lambda x.x, y z\rangle$
    
    \begin{itemize}
        \item Construcción de par $\langle t_1, t_2\rangle$
        \item $t_1 = \lambda x.x$ que es una abstracción bien formada
        \item $t_2 = y z$ es una aplicación donde:
        \begin{itemize}
            \item $y$ es variable $\rightarrow$ bien formada
            \item $z$ es variable $\rightarrow$ bien formada
            \item $y z$ es aplicación bien formada
        \end{itemize}
    \end{itemize}
    \textcolor{green!50!black}{El término está bien formado}
    
    \item $\mathsf{match}(t, x.r, y.)$
    
    \begin{itemize}
        \item La construcción $\mathsf{match}(t, x.s_1, y.s_1)$ requiere:
        \begin{itemize}
            \item $t$ bien formado 
            \item $x.s_1$ donde $s_1$ esté bien formado
            \item $y.s_2$ donde $s_2$ esté bien formado
        \end{itemize}
        \item El tercer argumento $y.$ está incompleto, falta el término después del punto

    \end{itemize}
   \textcolor{red!50!black}{El término no está bien formado} 
   
\end{enumerate}

\subsection{Parte 2}

\begin{ejercicio}
Verificar que \textbf{Set} es una categoría
\end{ejercicio}

\begin{enumerate}
    \item Obj(\textbf{Set}) son los conjuntos.
    \item Los morfismos, Hom(\textbf{Set}), son las funciones totales entre conjuntos.
    \item El operador de composición es la composición usual de funciones, donde dado 

    \( f \in \text{Hom}(A,B) \) y \( g \in \text{Hom}(B,C) \), queremos ver que existe \( h \in \text{Hom}(A,C) \) tal que
    \[
        h = g \circ f.
    \]
    La composición de funciones totales es una función total, por lo tanto \( h \) existe.
    \item Queremos ver que el operador de composición es asociativo, es decir, dado
    \[
        f \in \text{Hom}(A,B), \quad g \in \text{Hom}(B,C), \quad h \in \text{Hom}(C,D)
    \]
    se cumple
    \[
        h \circ (g \circ f) = (h \circ g) \circ f.
    \]
    \begin{itemize}
        \item Ida:
        \[
            (h \circ (g \circ f))(a) = h((g \circ f)(a)) = h(g(f(a)))
        \]
        \item Vuelta:
        \[
            ((h \circ g) \circ f)(a) = (h \circ g)(f(a)) = h(g(f(a)))
        \]
    \end{itemize}
    Por lo tanto las funciones son iguales.
    \item Por último, nos falta ver que existe \( \text{id}_A \in \text{Hom}(A,A) \) con \( A \in \text{Obj(\textbf{Set})} \).  
    
    Dado \( A \in \text{Obj(\textbf{Set})} \), definimos \( \text{id}_A \in \text{Hom}(A,A) \) como
    \[
        \text{id}_A(a) = a \quad \text{para todo } a \in A.
    \]
    Para cualquier \( f \in \text{Hom}(A,B) \):
    \[
        (\text{id}_B \circ f)(x) = \text{id}_B(f(x)) = f(x), \quad
        (f \circ \text{id}_A)(x) = f(\text{id}_A(x)) = f(x)
    \]
    Concluimos que \textbf{Set} es una categoría.
\end{enumerate}

\begin{ejercicio}
Probar que la composición de funciones que preservan el orden también preserva el orden, y que la identidad de cada conjunto parcialmente ordenado preserva el orden. Concluir que \textbf{Poset} es una categoría.
\end{ejercicio}

\begin{enumerate}
    \item Obj(\textbf{Poset}) son los conjuntos parcialmente ordenados, es decir, es una colección de pares \((P, \le_P)\) donde \(\le_P\) es un orden parcial para el conjunto \(P\).
    \item Los morfismos, Hom(\textbf{Poset}), son las funciones totales que preservan el orden. 

    Tienen la forma \( f: (P, \le_P) \to (Q, \le_Q) \) y que preserven el orden significa que
    \[
        a \le_P a' \implies f(a) \le_Q f(a').
    \]
    \item Sean \((A,\le_A), (B,\le_B), (C,\le_C) \in \text{Obj(\textbf{Poset})}\)
    \[
        f \in \text{Hom}[(A,\le_A),(B,\le_B)], \quad g \in \text{Hom}[(B,\le_B),(C,\le_C)]
    \]
    Queremos probar que \( h = g \circ f \in \text{Hom}[(A,\le_A),(C,\le_C)] \), es decir, que \(h\) preserva el orden.  
    
    Tomemos \( a_1, a_2 \in A \) tales que \( a_1 \le_A a_2 \). Sabemos que \( f(a_1) \le_B f(a_2) \).  
    Como \( f(a_1), f(a_2) \in B \), tenemos que \( g(f(a_1)) \le_C g(f(a_2)) \).  
    
    Luego \( h = g \circ f \):
    \[
        h(a_1) = g(f(a_1)), \quad h(a_2) = g(f(a_2))
    \]
    Por lo tanto, \( a_1 \le_A a_2 \implies h(a_1) \le_C h(a_2) \), y \( h \) preserva el orden.
    \item La asociatividad del operador de composición viene dada por la asociatividad de las funciones, demostrada en el punto anterior.
    \item Lo último para probar es que la identidad preserva el orden.  
    Sea \((A, \le_A) \in \text{Obj(\textbf{Poset})}\). Definimos
    \[
        \text{id}_A \in \text{Hom}[(A, \le_A), (A, \le_A)], \quad \text{id}_A(a) = a \text{ para todo } a \in A.
    \]
    Sean \( a_1, a_2 \in A \) tales que \( a_1 \le_A a_2 \). Vemos que
    \[
        \text{id}_A(a_1) = a_1, \quad \text{id}_A(a_2) = a_2
    \]
    Por lo que, si \( a_1 \le_A a_2 \), entonces \( \text{id}_A(a_1) \le_A \text{id}_A(a_2) \).  
    La identidad preserva el orden.
\end{enumerate}

Concluimos que \textbf{Poset} es una categoría.


\subsection{Parte 3}

\begin{ejercicio}
Determinar el producto tensorial entre $\mathbb{R}^3$ y $\mathbb{R}^2$: describir una base explícita 
de $\mathbb{R}^3 \times \mathbb{R}^2$ y su dimensión. 

¿Qué sucede si queremos calcular el producto tensorial entre $\mathbb{R}^3$ y $\mathbb{C}^2$?
¿Es posible hacerlo? Explicar.
\end{ejercicio}

Para espacios vectoriales de dimension finita, tenemos que
\[
\mathrm{dim}(\mathbb{R}^3 \otimes \mathbb{R}^2)
= \mathrm{dim}(\mathbb{R}^3)\cdot \mathrm{dim}(\mathbb{R}^2)
= 3 \cdot 2 = 6.
\]

Ahora, sean $A = \{a_1, a_2\}$ y $B = \{b_1, b_2, b_3\}$ bases canonicas para $\mathbb{R}^2$ y $\mathbb{R}^3$ respectivamente.
La base del producto tensorial $\mathbb{R}^3 \otimes \mathbb{R}^2$ viene dada por
\[
C = \{ b_i \otimes a_j : i \in \{1,2,3\},\ j \in \{1,2\} \}
= \{ b_1 \otimes a_1,\ b_1 \otimes a_2,\ b_2 \otimes a_1,\ b_2 \otimes a_2,\ b_3 \otimes a_1,\ b_3 \otimes a_2 \}.
\]

Para la segunda parte, comenzamos notando que el producto tensorial esta siempre definido
para espacios vectoriales sobre el mismo cuerpo, por lo que no podria, a priori, calcularlo entre
$\mathbb{R}^3$ y $\mathbb{C}^2$.
\\

Lo que si podemos hacer es llevar ambos espacio vectoriales sobre un mismo cuerpo. 

Lo mas sencillo es llevar todo a $\mathbb{R}$. 

Podemos pensar a $\mathbb{C}^2$ como un espacio vectorial sobre $\mathbb{R}$, el cual seria isomorfo a $\mathbb{R}^4$.

Ya que, sea $c$ un vector de $\mathbb{C}^2$, $c = (z_1,z_2)$ donde $z_1,z_2$ son numeros complejos,
pero a todo numero complejo lo puedo escribir como $z = a + bi$, donde $a,b$ son reales.
Por lo tanto $c = (a_1 + b_1 i,\ a_2 + b_2 i)$, que lo puedo representar como un vector
en $\mathbb{R}^4$ tal que $c = (a_1,b_1,a_2,b_2)$ entonces 
\[ \mathbb{C}^2 \cong \mathbb{R}^4 \]

Luego, como $\mathrm{dim}_{\mathbb{R}}(\mathbb{C}^2) = 4$, tenemos que
\[
\mathrm{dim}_{\mathbb{R}}(\mathbb{R}^3 \times \mathbb{C}^2)
= \mathrm{dim}_{\mathbb{R}}(\mathbb{R}^3) \cdot \mathrm{dim}_{\mathbb{R}}(\mathbb{C}^2)
= 3 \cdot 4 = 12.
\]
Es decir, puedo realizar la operacion llevando todo a $\mathbb{R}$, pero me aumenta la dimension del producto tensorial.


\begin{ejercicio}
Calcular los siguientes productos tensoriales de matrices / vectores.
\end{ejercicio}

\begin{enumerate}
    \item
    \[
    \begin{pmatrix} 1 \\ 2 \end{pmatrix}
    \otimes
    \begin{pmatrix} 3 & 4 \end{pmatrix}
    =
    \begin{pmatrix} 3 & 4 \\ 6 & 8 \end{pmatrix}
    \]

    \item
    \[
    \begin{pmatrix} 3 & 4 \end{pmatrix}
    \otimes
    \begin{pmatrix} 1 \\ 2 \end{pmatrix}
    =
    \begin{pmatrix} 3 & 4 \\ 6 & 8 \end{pmatrix}
    \]

    \item
    \[
    \begin{pmatrix} 2 \\ 1 \end{pmatrix}
    \otimes
    \begin{pmatrix} a & b \\ c & d \end{pmatrix}
    =
    \begin{pmatrix}
    2a & 2b \\
    2c & 2d \\
    a & b \\
    c & d
    \end{pmatrix}
    \]

    \item
    \[
    \begin{pmatrix} a & b \\ c & d \end{pmatrix}
    \otimes
    \begin{pmatrix} 2 \\ 1 \end{pmatrix}
    =
    \begin{pmatrix}
    2a & 2b \\
    a & b \\
    2c & 2d \\
    2c & d \\
    \end{pmatrix}
    \]

    \item
    \[
    \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix}
    \otimes
    \begin{pmatrix} 1 \\ 0 \end{pmatrix}
    =
    \begin{pmatrix}
    0 \\
    0 \\
    0 \\
    0 \\ 
    1 \\
    0
    \end{pmatrix}
    \]

    \item
    \[
    \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}
    \otimes
    \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}
    =
    \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    1 & 0 & 0 & 0 \\
    0 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
    \end{pmatrix}
    \]
\end{enumerate}

\section{Codificación superdensa}
El circuito completo queda de la siguiente manera
\begin{eqnarray*}
  \Qcircuit @C=1em @R=1em {
  & \gate{Z^{b_1}X^{b_2}} \qw	& \push{|} \qw	& \ctrl{2} \qw	& \gate{H}	& \meter	& \qw	& \rstick{\ket{b_1}} \\
  \lstick{\beta_{00}} & & \push{|} & & & & & \\
  & \qw				& \push{|} \qw	& \targ \qw	& \qw		& \meter	& \qw	& \rstick{\ket{b_2}}
                                                                    }
\end{eqnarray*}
donde la línea punteada determina el paso 4, en el que Alice envía su qubit a
Bob.

\subsection{Traza de Ejecucion}

Tomaremos como operadores de medicion al conjunto $\{P_{00},P_{01},P_{10},P_{11}\}$ tales que:

\begin{align*}
P_{00} = \ket{00}\bra{00} \\
P_{01} = \ket{01}\bra{01} \\
P_{10} = \ket{10}\bra{10} \\
P_{11} = \ket{11}\bra{11} \\
\end{align*}

\begin{ejemplo}
Si se quiere enviar el bit $00$ se aplica $(I\otimes I)$ a
$\beta_{00}$, por lo que el no se modifica el estado de bell:

\begin{align*}
(I\otimes I)\beta_{00}
&= I \otimes \beta_{00}\\
&= I \otimes \frac{1}{\sqrt{2}}(\ket{00}+\ket{11})=\beta_{00}
\end{align*}

con lo que se obtiene $\beta_{00}$. Luego aplicamos $(H\otimes I) CNOT \beta_{00} $ para recuperar los bits:

\begin{align*}
(H\otimes I) CNOT \beta_{00}
&= (H\otimes I) (CNOT (\frac{1}{\sqrt{2}}(\ket{00}+\ket{11})))\\
&= (H\otimes I) (\frac{1}{\sqrt{2}}(\ket{00}+\ket{10}))\\
&= (H\otimes I) (\frac{\ket{0}+\ket{1}}{\sqrt{2}} \otimes \ket{0})\\
&= (\frac{(\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) + (\frac{1}{\sqrt{2}}(\ket{0}-\ket{1}))}{\sqrt{2}} \otimes \ket{0})\\
&= (\frac{{\sqrt{2}}\ket{0}}{\sqrt{2}} \otimes \ket{0}) = \ket{00} 
\end{align*}

Luego obtenemos la medicion tal que:

\begin{align*}
P(0) = \bra{00} M_{0} \ket{00} = \bra{00}\ket{00}\bra{00} \ket{00} = \ket{00} \bra{00} \ket{00}  = \ket{00} = 1\\
P(1) = \bra{00} M_{1} \ket{00} = \bra{00}\ket{01}\bra{01} \ket{00} = 0\\
P(2) = \bra{00} M_{2} \ket{00} = \bra{00}\ket{10}\bra{10} \ket{00} = 0\\
P(3) = \bra{00} M_{3} \ket{00} = \bra{00}\ket{11}\bra{11} \ket{00} = 0\\
\end{align*}

\end{ejemplo}

\begin{ejemplo}
Si se quiere enviar el bit $01$ se aplica $(X\otimes I)$ a
$\beta_{00}$, el estado de bell se modificara de la siguiente manera:

\begin{align*}
(X\otimes I)\beta_{00}
&= (X \otimes I) \frac{1}{\sqrt{2}}(\ket{00}+\ket{11})\\
&= \frac{1}{\sqrt{2}}(\ket{10}+\ket{01}) = \frac{1}{\sqrt{2}}(\ket{01}+\ket{10}) = \beta_{01}\\
\end{align*}

con lo que se obtiene $\beta_{01}$. Luego aplicamos $(H\otimes I) CNOT \beta_{01} $ para recuperar los bits:

\begin{align*}
(H\otimes I) CNOT \beta_{01}
&= (H\otimes I) (CNOT (\frac{1}{\sqrt{2}}(\ket{01}+\ket{10})))\\
&= (H\otimes I) (\frac{1}{\sqrt{2}}(\ket{01}+\ket{11}))\\
&= (H\otimes I) (\frac{\ket{0}+\ket{1}}{\sqrt{2}} \otimes \ket{1})\\
&= (\frac{(\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) + (\frac{1}{\sqrt{2}}(\ket{0}-\ket{1}))}{\sqrt{2}} \otimes \ket{1})\\
&= (\frac{{\sqrt{2}}\ket{0}}{\sqrt{2}} \otimes \ket{0}) = \ket{01} 
\end{align*}

Luego obtenemos la medicion tal que:

\begin{align*}
P(0) = \bra{01} M_{0} \ket{01} = \bra{01}\ket{00}\bra{00} \ket{01} = 0 \\
P(1) = \bra{01} M_{1} \ket{01} = \bra{01}\ket{01}\bra{01} \ket{01} = \ket{01} \bra{01} \ket{01}  = \ket{01} = 1\\
P(2) = \bra{01} M_{2} \ket{01} = \bra{01}\ket{10}\bra{10} \ket{01} = 0\\
P(3) = \bra{01} M_{3} \ket{01} = \bra{01}\ket{11}\bra{11} \ket{01} = 0\\
\end{align*}

\end{ejemplo}

\begin{ejemplo}
Si se quiere enviar el bit $10$ se aplica $(Z\otimes I)$ a
$\beta_{00}$, el estado de bell se modificara de la siguiente manera:

\begin{align*}
(Z\otimes I)\beta_{00}
&= (Z \otimes I) \frac{1}{\sqrt{2}}(\ket{00}+\ket{11})\\
&= \frac{1}{\sqrt{2}}(\ket{00}-\ket{11}) = \frac{1}{\sqrt{2}}(\ket{00}-\ket{11}) = \beta_{10}\\
\end{align*}

con lo que se obtiene $\beta_{10}$. Luego aplicamos $(H\otimes I) CNOT \beta_{10} $ para recuperar los bits:

\begin{align*}
(H\otimes I) CNOT \beta_{10}
&= (H\otimes I) (CNOT (\frac{1}{\sqrt{2}}(\ket{00}-\ket{11})))\\
&= (H\otimes I) (\frac{1}{\sqrt{2}}(\ket{00}-\ket{10}))\\
&= (H\otimes I) (\frac{\ket{0}-\ket{1}}{\sqrt{2}} \otimes \ket{0})\\
&= (\frac{(\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) - (\frac{1}{\sqrt{2}}(\ket{0}-\ket{1}))}{\sqrt{2}} \otimes \ket{0})\\
&= (\frac{{\sqrt{2}}\ket{1}}{\sqrt{2}} \otimes \ket{0}) = \ket{10} 
\end{align*}

Luego obtenemos la medicion tal que:

\begin{align*}
P(0) = \bra{10} M_{0} \ket{10} = \bra{10}\ket{00}\bra{00} \ket{10} = 0\\
P(1) = \bra{10} M_{1} \ket{10} = \bra{10}\ket{01}\bra{01} \ket{10} = 0\\
P(2) = \bra{10} M_{2} \ket{10} = \bra{10}\ket{10}\bra{10} \ket{10} = \ket{10} \bra{10} \ket{10}  = \ket{10} = 1\\
P(3) = \bra{10} M_{3} \ket{10} = \bra{10}\ket{11}\bra{11} \ket{10} = 0\\
\end{align*}
\end{ejemplo}

\begin{ejemplo}
Si se quiere enviar el bit $11$ se aplica $(ZX\otimes I)$ a
$\beta_{00}$, el estado de bell se modificara de la siguiente manera:


\begin{align*}
(ZX\otimes I)\beta_{00}
&=(Z\otimes I)\left((X\otimes I)\beta_{00}\right)\\
&=(Z\otimes I)\left((X\otimes I)\frac{1}{\sqrt{2}}(\ket{00}+\ket{11})\right)\\
&=(Z\otimes I)\left(\frac{1}{\sqrt{2}}(\ket{10}+\ket{01})\right)\\
&=\frac{1}{\sqrt{2}}(-\ket{10}+\ket{01})=\beta_{11}
\end{align*}


con lo que se obtiene $\beta_{11}$. Luego aplicamos $(H\otimes I) CNOT \beta_{11} $ para recuperar los bits:

\begin{align*}
(H\otimes I) CNOT \beta_{11}
&= (H\otimes I) (CNOT (\frac{1}{\sqrt{2}}(\ket{01}-\ket{10})))\\
&= (H\otimes I) (\frac{1}{\sqrt{2}}(\ket{01}-\ket{11}))\\
&= (H\otimes I) (\frac{\ket{0}-\ket{1}}{\sqrt{2}} \otimes \ket{1} )\\
&= (\frac{(\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) - (\frac{1}{\sqrt{2}}(\ket{0}-\ket{1}))}{\sqrt{2}})\\
&= (\frac{{\sqrt{2}}\ket{1}}{\sqrt{2}} \otimes \ket{1}) = \ket{11} 
\end{align*}

Luego obtenemos la medicion tal que:

\begin{align*}
P(0) = \bra{11} M_{0} \ket{11} = \bra{11}\ket{00}\bra{00} \ket{11} = 0\\
P(1) = \bra{11} M_{1} \ket{11} = \bra{11}\ket{01}\bra{01} \ket{11} = 0\\
P(2) = \bra{11} M_{2} \ket{11} = \bra{11}\ket{10}\bra{10} \ket{11} = 0\\
P(3) = \bra{11} M_{3} \ket{11} = \bra{11}\ket{11}\bra{11} \ket{11} = \ket{11} \bra{11} \ket{11}  = \ket{11} = 1\\
\end{align*}
\end{ejemplo}

\subsection{Término y Tipado para control clasico}


\subsubsection{Término del Algoritmo}

\begin{align*}
EPR = \lambda _. (CNOT <H \,new \, 0, new \, 0>) \\ \\
\end{align*}

\begin{align*}
Alice = \lambda q_a. \lambda <b_1,b_2>. \\  
& if \, b_1 \, then \, \\ 
&\qquad if \, b_2 \, then \, Z \, X \, q_a\, \\
&\qquad else \, Z \, q_a\, \\
& else \\
&\qquad if \, b_2 \, then X \, q_a\, \\ 
&\qquad else \, I \, q_a\, \\ 
\end{align*}

\begin{align*}
Bob = \lambda q_1. \lambda q_2. \,let <q_1', q_2'> = CNOT <q_1, q_2> in <H \, q_1', q_2'>
\end{align*}

El termino principal queda definido por:

\begin{align*}
SDC = \lambda b_1. \lambda b_2. \\
&let \, <q_a, q_b> = EPR \,* \,in \\
&let \, q_a' = Alice \, q_a \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',q_b'> \\ 
& in <meas \, q_a'', meas \, q_b''>\\ 
\end{align*}

\subsubsection{Tipado del Término}

El tipo del término es:

$$\vdash M_{SD} : !(\mathsf{bit} \multimap \mathsf{bit} \multimap \mathsf{qbit} \otimes \mathsf{qbit} \multimap \mathsf{bit} \otimes \mathsf{bit})$$

\begin{itemize}
\item $\mathsf{bit}$: tipo de bits clásicos 
\item $\mathsf{qbit}$: tipo de qubits
\item $\multimap$: implicación lineal 
\item $!T$: tipo de términos duplicables/clonables
\end{itemize}

\subsubsection{Traza de reduccion}

Tomamos la reduccion para la transmisicion de $(0,0)$

\begin{align*}
[,,SDC \,0 \,0] \\ \\
[,,(\lambda b_1. \lambda b_2. \\ 
&let \, <q_a, q_b> = EPR \,* \,in \\
&let \, q_a' = Alice \, q_a \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',q_b> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\ \\
[,, \\ 
&let \, <q_a, q_b> = ( \lambda _. (CNOT <H \,new \, 0, new \, 0>)) \,* \,in \\
&let \, q_a' = Alice \, q_a \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',q_b> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\ \\
[\ket{0}\ket{0},,(\lambda b_1. \lambda b_2. \\ 
&let \, <q_a, q_b> = (CNOT <H \,p_0, \,p_1>) \,in \\
&let \, q_a' = Alice \, q_a \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',q_b> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\
[\ket{0}\ket{0},,(\lambda b_1. \lambda b_2. \\ 
&let \, <q_a, q_b> = CNOT <H \,p_0, \,p_1> \,in \\
&let \, q_a' = Alice \, q_a \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',q_b> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\ \\
[\ket{+}\ket{0},,(\lambda b_1. \lambda b_2. \\ 
&let \, <q_a, q_b> = (CNOT <\,p_0, \,p_1>) \,* \,in \\
&let \, q_a' = Alice \, q_a \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',q_b> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,(\lambda b_1. \lambda b_2. \\ 
&let \, <q_a, q_b> = <p_0, p_1> \,in \\
&let \, q_a' = Alice \, q_a \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',q_b> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,(\lambda b_1. \lambda b_2. \\ 
&let \, q_a' = Alice \, p_0 \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,(\lambda b_1. \lambda b_2. \\ 
&let \, q_a' = (\lambda q_a. \lambda <b_1,b_2>. \\  
& if \, b_1 \, then \, \\ 
&\qquad if \, b_2 \, then \, Z \, X \, q_a\, \\
&\qquad else \, Z \, q_a\, \\
& else \\
&\qquad if \, b_2 \, then X \, q_a\, \\ 
&\qquad else \, I \, q_a\, \\ )\, p_0 \, <b_1,b_2> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>) 0 \,0] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,\\ 
&let \, q_a' = (\lambda q_a. \lambda <b_1,b_2>. \\  
& if \, b_1 \, then \, \\ 
&\qquad if \, b_2 \, then \, Z \, X \, q_a\, \\
&\qquad else \, Z \, q_a\, \\
& else \\
&\qquad if \, b_2 \, then X \, q_a\, \\ 
&\qquad else \, I \, q_a\, \\ )\, p_0 \, <0,0> \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,\\ 
&let \, q_a' = \\  
& if \, 0 \, then \, \\ 
&\qquad if \, 0 \, then \, Z \, X \, p_0\, \\
&\qquad else \, Z \, p_0\, \\
& else \\
&\qquad if \, 0 \, then X \, p_0\, \\ 
&\qquad else \, I \, p_0\, \\ \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,\\ 
&let \, q_a' = \\  
& if \, 0 \, then \, \\ 
&\qquad if \, 0 \, then \, Z \, X \, p_0\, \\
&\qquad else \, Z \, p_0\, \\
& else \\
&\qquad if \, 0 \, then X \, p_0\, \\ 
&\qquad else \, I \, p_0\, \\ \, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,\\ 
&let \, q_a' = p_0\, in \\ 
&let \, <q_a'', q_b''> = Bob \, <q_a',p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,\\  
&let \, <q_a'', q_b''> = Bob \, <p_0,p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,\\  
&let \, <q_a'', q_b''> = (\lambda q_1. \lambda q_2. \,let <q_1', q_2'> = \\ 
&\qquad CNOT <q_1, q_2> in <H \, q_1', q_2'>)\, <p_0,p_1> \\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[B_{00},p_0 \rightarrow 0, p_1 \rightarrow 1,\\  
&let \, <q_a'', q_b''> = \,let <q_1', q_2'> = \\ 
&\qquad CNOT <p_0, p_1> in <H \, q_1', q_2'> \\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[\ket{+} \ket{0},p_0 \rightarrow 0, p_1 \rightarrow 1,\\  
&let \, <q_a'', q_b''> = (\,let <q_1', q_2'> = \\ 
&\qquad CNOT <p_0, p_1> in <H \, q_1', q_2'> )\\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[\ket{+} \ket{0},p_0 \rightarrow 0, p_1 \rightarrow 1,\\  
&let \, <q_a'', q_b''> = (<H \, p_0, p_1> )\\ 
& in <meas \, q_a'', meas \, q_b''>] \\
[\ket{0} \ket{0},p_0 \rightarrow 0, p_1 \rightarrow 1,\\ 
& in <meas \, p_0, meas \, p_1>] \\
\end{align*}



\subsection{Termino en calculo Lambda-S}

Definimo un termino para cada compuerta que utilizaremos: 

\begin{align*}
H = \lambda x : B.x? \ket{-}. \ket{+} : B \Rightarrow SB\\ \\
\end{align*}

Donde $\ket{+}$ y $\ket{-}$ estaran definidos de la siguiente manera:

\begin{align*}
\ket{-} = \frac{1}{\sqrt{2}}\ket{0}-\frac{1}{\sqrt{2}}\ket{1}\\ \\ 
\ket{+} = \frac{1}{\sqrt{2}}\ket{0}+\frac{1}{\sqrt{2}}\ket{1} \\ \\
\end{align*}

Luego tenemos: 

\begin{align*}
Z = \lambda x : B.x? (-\ket{1}). \ket{0}: B \Rightarrow SB\\ \\
NOT = \lambda x : B.x? \ket{0}. \ket{1}: B \Rightarrow B\\ \\
CNOT = \lambda q : BXB. (\lambda q_1 .(\lambda q_2. q_1 ? q_1 \\ 
\times (NOT\,q_2)  . q_1 \times q_2) tail \, q)head\,q : B\times B \rightarrow B\times B
\end{align*}



Apartir de la composicion de esta compuertas podemos generar el circuito completo:

\begin{align*}
& EPR = \frac{1}{\sqrt{2}}(\ket{00}+\ket{11})  : S(B \times B) \\ \\
& ALICE = \lambda q: B \times B. \\
&\qquad (\lambda q_1.\; (\lambda q_2.\; \\
&\qquad\qquad q_1? \\
&\qquad\qquad\qquad q_2? \\
&\qquad\qquad\qquad\qquad \lambda bell.\; NOT(Z\, bell)\; \\ 
&\qquad\qquad\qquad\qquad .\lambda bell.\; Z\, bell\; \\
&\qquad\qquad.q_2? \lambda bell.\; NOT\, bell \\
&\qquad\qquad\qquad .\lambda bell. bell \\ 
&\qquad )) {tail}(q))\; {head}(q) : B \times B \rightarrow (SB \Rightarrow SB) \\ \\
& BOB = \lambda q : S(B \times B).\; 
            \pi_2 \Big( 
                \big(\lambda qn : S(B \times B).\; 
                    H(\text{head}\, qn) \times (\text{tail}\, qn)
                \big)(\text{CNOT}\, q) 
            \Big) 
       : S(B \times B) \Rightarrow B \times B
\end{align*} \\ \\

& SDC = \lambda b: B \times B. Bob ((Alice \, b) EPR)\\
\end{align*}


\subsubsection{Tipado del Término}

El tipo del término $\mathtt{SDC}$ es:

\[
\vdash \mathtt{SDC} : B \times B \Rightarrow B \times B \text{(no se si es asi creo que al final es D(BxB) no BxB, igual en bob }
\]


\subsubsection{Traza de reduccion}

Tomamos la reduccion para la transmisicion de $(0,0)$

\[
\code{SDC}(\ket{00}) = \code{BOB}\big((\code{ALICE}\,\ket{00})\,\code{EPR}\big)
\]


\begin{align*}
\code{ALICE}\,\ket{00} &\rightarrow
 \lambda q. \\
&\qquad (\lambda q_1.\; (\lambda q_2.\; \\
&\qquad\qquad q_1? \\
&\qquad\qquad\qquad q_2? \\
&\qquad\qquad\qquad\qquad \lambda bell.\; NOT(Z\, bell)\; \\ 
&\qquad\qquad\qquad\qquad .\lambda bell.\; Z\, bell\; \\
&\qquad\qquad.q_2? \lambda bell.\; NOT\, bell \\
&\qquad\qquad\qquad .\lambda bell. bell \\ 
&\qquad )) {tail}(q))\; {head}(q)  \\ \\
&\text{head}(\ket{00}) = \ket{0} \text{ y } {tail}(\ket{00})  = \ket{0} \text{ El condicional } q_1?\text{ se evalúa.} \\
&\text{Como } q_1 = \ket{0} \text{, se reduce a la rama derecha :} \\
\end{align*}
\begin{align*}
&\rightarrow (\lambda q_2.\, q_2?\,\lambda bell.\,\code{NOT}\, bell\,.\,\lambda bell.\,bell)\,\ket{0}
\end{align*}


\begin{align*}
&\rightarrow \ket{0}?\,\lambda bell.\,\code{NOT}\, bell\,.\,\lambda bell.\,bell
\end{align*}

\begin{align*}
&\rightarrow \lambda bell.\,bell
\end{align*}


\begin{align*}
(\code{ALICE}\,\ket{00})\,\code{EPR} &\rightarrow (\lambda bell.\,bell)\,\code{EPR}
\end{align*}

\begin{align*}
(\lambda bell.\,bell)\,\code{EPR}  &\rightarrow \code{EPR'}
\end{align*}

\begin{align*}
\code{SDC}(\ket{00}) \rightarrow \code{BOB}(\code{EPR}') \\
\end{align*}
\begin{align*}
\code{BOB}(\code{EPR}') = \pi_2 \Big( 
                \big(\lambda qn.\; 
                    H(\text{head}\, qn) \times (\text{tail}\, qn)
                \big)(\text{CNOT}\, \code{EPR'}) 
            \Big) 
\end{align*}

Primero evaluamos la aplicación de $\code{CNOT}$ al estado $\code{EPR}'$.


\[
\code{CNOT}(\code{EPR}') = \code{CNOT}\left(\frac{1}{\sqrt{2}}(\ket{00} + \ket{11})\right)
\]

$\code{CNOT}$ se distribuye linealmente:

\begin{align*}
\code{CNOT}\left(\frac{1}{\sqrt{2}}(\ket{00} + \ket{11})\right) 
&= \frac{1}{\sqrt{2}}\,\code{CNOT}(\ket{00}) + \frac{1}{\sqrt{2}}\,\code{CNOT}(\ket{11}) \\
&= \frac{1}{\sqrt{2}}\ket{00} + \frac{1}{\sqrt{2}}\ket{10}
\end{align*}

Finalmente

\begin{align*}
\code{CNOT}(\code{EPR}')  &\rightarrow \frac{1}{\sqrt{2}}(\ket{00} + \ket{10})
\end{align*}




\[
qn = \frac{1}{\sqrt{2}}(\ket{00} + \ket{10})
\]

El estado $qn$ es separable:
\[
qn = \left(\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\right) \times \ket{0} = \ket{+} \times \ket{0}
\]

Queda entonces:

\begin{align*}
\code{BOB}(\code{EPR}') 
&= \pi_2 \Big( 
    \big(\lambda qn.\; 
        H(\text{head}\, qn) \times (\text{tail}\, qn)
    \big)(\ket{+} \times \ket{0}) 
\Big) \\
&\rightarrow \pi_2 \big( H(\text{head}\, (\ket{+} \times \ket{0})) \times (\text{tail}\, (\ket{+} \times \ket{0})) \big) \quad \text{(Aplicando $\beta$)} \\
&= \pi_2 \big( H(\ket{+}) \times \ket{0} \big) \quad  \\
\end{align*}


Se aplica $H$ al primer qubit $\ket{+}$.
$H$ se distribuye linealmente sobre $\ket{+}$:

\begin{align*}
H(\ket{+}) &= H\left(\frac{1}{\sqrt{2}}\ket{0} + \frac{1}{\sqrt{2}}\ket{1}\right) \\
&\rightarrow \frac{1}{\sqrt{2}} H(\ket{0}) + \frac{1}{\sqrt{2}} H(\ket{1})
\end{align*}

\[
\rightarrow \frac{1}{\sqrt{2}}\ket{+} + \frac{1}{\sqrt{2}}\ket{-}
\]


\begin{align*}
&\rightarrow \frac{1}{\sqrt{2}}\left(\frac{1}{\sqrt{2}}(\ket{0}+\ket{1})\right) + \frac{1}{\sqrt{2}}\left(\frac{1}{\sqrt{2}}(\ket{0}-\ket{1})\right) \\
&\rightarrow \frac{1}{2}(\ket{0}+\ket{1}) + \frac{1}{2}(\ket{0}-\ket{1}) \\
&\rightarrow \ket{0}
\end{align*}

Queda entonces:

\[
\code{BOB}(\code{EPR}') \rightarrow \pi_2(\ket{00})
\]
\\
Dado que el estado $\ket{00}$ es un término de base con  coeficiente de amplitud  1(creo que se llama asi), la medición resulta en:

\[
\pi_2(\ket{00}) \rightarrow \{1\}\ket{00}
\]

\subsection{Termino en calculo Lb}
Definimos como macros:

\begin{align*}
\ket{0} = <*, \, 0.*> \\
\ket{1} = <0.*,*>
\end{align*}

Empecemos codificando las compuertas basicas:
\begin{align*}
X = \lambda x:1 \& 1.(\ket{1} \,. \delta¹ (x,x_1.x_1) + \ket{0} \,. \delta²(x,x_2.x_2) ): 1\&1 \roundarrow 1\& 1 \\ \\
Z = \lambda x:1 \& 1.(\ket{0} \,. \delta¹ (x,x_1.x_1) + (-1.\ket{1}) \,. \delta²(x,x_2.x_2) ): 1\&1 \roundarrow 1\& 1 \\ \\
H = \lambda x:1 \& 1.(\frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \,. \delta¹ (x,x_1.x_1) + (\frac{1}{\sqrt{2}}(\ket{0} - \ket{1}) \,. \delta²(x,x_2.x_2) ): 1\&1 \roundarrow 1\& 1 \\ \\
CNOT = \lambda z: 1 \& 1 \times 1 \& 1.\delta_{\otimes}(z,xy.\frac{1}{2}.(x x y) + \frac{1}{2}.(Z x x y) + \frac{1}{2}.(x x X y) + -\frac{1}{2}.(Z x x X))\\
\end{align*}

Luego definimos una macro para $B_{00}$

\begin{align*}
B_{00} = \frac{1}{\sqrt{2}}.(<*,0.*> \times <*,0.*>) + \frac{1}{\sqrt{2}}.(<0.*,*>) \times <0.*,*>))    
\end{align*}

Con esto pasamos a construir los componentes claves para la obtension de circuito:

\begin{align*}
ALICE = \lambda b_1 : 1+ 1.\lambda b_2: 1+1. \lambda q: 1\&1. \delta_{\bigoplus}(b_1, x_1.\delta_{\bigoplus}(b_2, x_2.q, y_2.X \,q), \\ 
\, y_1.\delta_{\bigoplus}(b_2, x_2.Z \, q, y_2. Z \, X \, q)) : 1+1 \roundarrow 1+1 \roundarrow 1\&1 \roundarrow 1\&1
\end{align*}

Quiero modelar el hecho de que Alice opera localmente sobre su qubit, para eso
voy a tener una funcion ENCODING sea tal que me tome los dos bits clasicos
y el par entrelazado EPR y me devuelve un par

\begin{align*}
ENCODING = \lambda b_0 : 1+1.\lambda b_1 : 1+1.\lambda q : 1\&1. \delta_{\otimes}(q, yz.(ALICE \, b_0 \,b_1 \,y) \, x \, z) : 1+1 \roundarrow 1+1 \roundarrow 1\&1 \times 1\&1 \roundarrow 1\&1 \times 1\&1
\end{align*}

Para construir $BOB$ definimos:

\begin{align*}
HxI = \lambda q : 1\&1\times1\&1.\delta_{\otimes}(q, yz.(H\,y) \, x \, z):1\&1\times1\&1 \roundarrow 1\&1\times1\&1   
\end{align*}

Luego:

\begin{align*}
BOB = \lambda q:1\&1.(HxI)(CNOT \, q):1\&1 \roundarrow 1\&1   
\end{align*}

Para establecer la medicion tenemos: 

\begin{align*}
BIT(0,0) = inl(*) \times inl(*) \\
BIT(0,1) = inl(*) \times inr(*) \\
BIT(1,0) = inr(*) \times inl(*) \\
BIT(1,1) = int(*) \times inr(*) \\ \\
Proj_{ij}(q) = \delta_{\otimes} (q. xy.(Proj_i(x) . Proj_j(y))) \\
Proj_0 = \delta_&^1(x,x1.x1) \\
Proj_1 = \delta_&^2(x,x2.x2) 
\end{align*}

Luego tenemos que:

\begin{align*}
SDC = \lambda b_1 :1+1.\lambda b_2 :1+1. MEAS(BOB(ENCODING \, b_1 \, b_2 \, B_{00})) \\
:1+1 \roundarrow 1+1 \roundarrow (1+1 \times 1+1)
\end{align*}

\subsubsection{Tipado del termino}

\subsubsection{Traza de reduccion}

\end{document}